<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Ptolemy</title>
  <script src="munich2.osm.js"></script>
  <style>
polyline {
  fill: none; stroke: black; stroke-width: 0.5px;
}
canvas {
  border: 1px solid black; height: 570px; width: 700px
}
  </style>
</head>
<body>
  <canvas id="canvas" height="570" width="700"></canvas>

  <script type="text/javascript">
    var CURRENT_ZOOM = 15;

    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');

    // --- Constants & helpers to do meter -> pixel conversion ---

    // The 20037508.342789241555641 corresponds roughly to 1/2 of the equator
    // extend. As calculated from the radius of the earth: 2 * PI * 6378137 / 2.
    var equatorExtendHalf = 20037508.342789241555641;
    var equatorExtend = equatorExtendHalf * 2;
    var TILE_SIZE = 256; // 256 x 256 is the default tile size.

    function calcPixelPerMeter(zoomLevel) {
      var numberOfTiles = Math.pow(2, zoomLevel);
      return TILE_SIZE * numberOfTiles / equatorExtend;
    }

    // --- Add margin around the map and color background ---
    var mapMargin = 10;
    var canvasWidth = canvas.width - 2 * mapMargin;
    var canvasHeight = canvas.height - 2 * mapMargin;
    ctx.translate(mapMargin, mapMargin);

    // Draw the background of the map.
    ctx.fillStyle = 'rgb(237, 230, 220)';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    // --- Translate the canvas context to make drawing go at the right spot ---
    var bounds = MAP_DATA.bounds;

    var pixelPerMeter = calcPixelPerMeter(CURRENT_ZOOM);
    ctx.translate(-bounds.minx * pixelPerMeter, -bounds.miny * pixelPerMeter);

    // --- Actual rendering ---

    // Adjust this based on current zoom level.
    var LINE_WIDTH_ROOT = 0.4; 


    var ways = MAP_DATA.ways;
    var nodes = MAP_DATA.nodes;

    function drawArea(shape, fillShape) {
      ctx.beginPath();

      for (var i = 0; i < shape.length; i++) {
        var nodeIdx = shape[i];
        var node = nodes[nodeIdx];

        // var x = node[0] - minlon;
        // var y = maxlat - node[1];
        var x = node[0] * pixelPerMeter;
        var y = node[1] * pixelPerMeter;

        if (i == 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        } 
      }

      if (fillShape) {
        ctx.fill();
      } else {
        ctx.stroke();
      }
    }

    var wayMapping = [
      {
        name: 'landuse',
        fill: true,
        fillStyle: 'green'
      },
      {
        name: 'waterway',
        fill: true,
        strokeStyle: '#00899E',
        fillStyle: '#00899E',
        lineWidth: LINE_WIDTH_ROOT * 5,
      },
      {
        name: 'amenity',
        fill: true,
        fillStyle: 'rgb(244, 208, 207)'
      },
      {
        name: 'natural',
        fill: true,
        fillStyle: '#68B300'
      },
      {
        name: 'leisure',
        fill: true,
        fillStyle: '#68B300'
      },
      {
        name: 'surface',
        fill: false,
        strokeStyle: 'brown',
        lineWidth: LINE_WIDTH_ROOT * 1
      },
      {
        name: 'place',
        fill: true,
        fillStyle: 'burlywood'
      },
      {
        name: 'building',
        fill: true,
        fillStyle: 'burlywood'
      },
      {
        name: 'barrier',
        fill: true,
        fillStyle: 'burlywood'
      },
      {
        name: 'highway',
        fill: false,
        strokeStyle: 'orange',
        lineWidth: LINE_WIDTH_ROOT * 3
      },
    ];

    console.time('render-start');

    // Rounded lines look cute :)
    ctx.lineCap = 'round';

    // Draw all the ways.
    for (var i = 0; i < wayMapping.length; i++) {
      var wayMap = wayMapping[i];
      var wayCache = MAP_DATA.cache[wayMap.name];
      var fillWay = wayMap.fill;

      assert(wayCache);

      ctx.lineWidth = wayMap.lineWidth;
      ctx.strokeStyle = wayMap.strokeStyle;
      ctx.fillStyle = wayMap.fillStyle;
      if (wayMap.name === 'waterway') {
        for (var n = 0; n < wayCache.length; n++) {
          var way = ways[wayCache[n]];
          drawArea(way.nodes, way.tags['waterway'] == 'riverbank');
        }  
      } else if (wayMap.name === 'highway') {

        var bigRoadWidth = LINE_WIDTH_ROOT * 10;
        var outlines = [
            'tertiary', 'tertiary_link', 'secondary', 'secondary_link', 
            'living_street', 'residential'
          ];

        ctx.strokeStyle = '#686523';
        ctx.lineWidth = bigRoadWidth * 1.1;

        // First loop is about painting all the outlines.
        for (var n = 0; n < wayCache.length; n++) {
          var way = ways[wayCache[n]];
          var type = way.tags.highway;

          if (outlines.indexOf(type) !== -1) {
            drawArea(way.nodes, false);  
          }
        }

        for (var n = 0; n < wayCache.length; n++) {
          var way = ways[wayCache[n]];
          var type = way.tags.highway;

          if (!setHighwayStyle(ctx, type)) {
            continue;
          }
          drawArea(way.nodes, false);
        }  
      } else {
        for (var n = 0; n < wayCache.length; n++) {
          var way = ways[wayCache[n]];
          drawArea(way.nodes, fillWay);
        }    
      }  
    }
    
    console.timeEnd('render-start');

    function setHighwayStyle(ctx, type) {
      switch (type) {
        case 'unclassified':
        case 'cycleway':
        case 'elevator':
        case 'crossing':
          // Ignore these for now.
          return false;
          break;

        case 'motorway':
        case 'motorway_link':
        case 'trunk':
        case 'trunk_link':
          ctx.strokeStyle = '#FFA200';
          ctx.lineWidth =  bigRoadWidth;
          break;

        case 'tertiary':
        case 'tertiary_link':
        case 'secondary':
        case 'secondary_link':
          ctx.strokeStyle = '#F7EF0D';
          ctx.lineWidth =  bigRoadWidth;
          break;

        case 'living_street':
        case 'residential':
          ctx.strokeStyle = 'white';
          ctx.lineWidth = bigRoadWidth;
          break;

        case 'construction':
        case 'steps':
        case 'footway':
        case 'pedestrian':
        case 'path':
        case 'service':
          ctx.strokeStyle = 'white';
          ctx.lineWidth = bigRoadWidth * 0.3;
          break;

        case 'track':
          ctx.strokeStyle = 'white';
          ctx.lineWidth = bigRoadWidth * 0.3;
          break;

        default:
          console.log('unsupportd highway type:', type);
          ctx.strokeStyle = 'red';
          ctx.lineWidth = bigRoadWidth;
          break;
      }
      return true;
    }

    // --- Helper assert() function ---

    function AssertionError(msg) {
      this.message = msg || "";
      this.name = "AssertionError";
    }
    AssertionError.prototype = Error.prototype;

    /* Call assert(cond, description1, ...)
      An AssertionError will be thrown if the cond is false.  All parameters will be logged to the console, 
      and be part of the error.
      */
    function assert(cond) {
      if (! cond) {
        var args = ["Assertion error:"].concat(Array.prototype.slice.call(arguments, 1));
        console.error.apply(console, args);
        // This is mostly for Firefox, and should perhaps be conditional on that;
        // this is because the standard Web Console often doesn't show proper stacks for errors
        // (depending on where the error was thrown)
        if (console.trace) {
          console.trace();
        }
        throw new AssertionError(args.join(" "));
      }
    }

  </script>

</body>
</html>
